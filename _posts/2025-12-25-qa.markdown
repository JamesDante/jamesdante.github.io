---
layout: post
title:  "中小团队如何设计QA以保证软件项目质量"
date:   2025-12-24 10:48:41 +0800
categories: 项目管理
---

现在很多中小开发团队，开发人手都不足甚至根本腾不出专门的QA人员。这种现象导致了一个结果，用户/客户到手的产品一点一个问题，轻则少不了一顿抱怨，重则就后会无期了。

如果让开发人员同时负责QA，你会发现开发人员都说测试没问题了，结果你点开还是一堆问题，这样来来回回不仅耗时而且特别消耗大家情绪和精力。

在需求管理和开发上我们可以做到敏捷，那么在QA上如何运用这一哲学？因为你不能说bug fix是增量的。一个bug可能反复出现，改了A导致了B这种现象可以说是非常常见。

如果QA不可能“像需求和开发那样敏捷”，能不能在“风险控制方式”上做到敏捷？

也不是不能，但是需要转换下视角，传统开发模式就是“等你都做完了，我来帮你找问题” 这种方式显然太瀑布了，而敏捷化就变成“如何尽快的暴露问题”。

这意味着QA在开发的同时也在进行。这说起来很轻松但如何真正落地实践是非常困难的。敏捷QA不是让bug消失得更快，而是让“系统会在哪里再次出问题”这件事变得更可预测。

开发人员就像是手上拿着锤子的人，看什么东西都想去通过锤这个动作来“交互”，但用户可不会这样想，用户可能以任何可能的方式与系统进行交互。  

所以每一个改动，都要回答三个问题：  
1. 它改的是哪个抽象层？
2. 这个层被谁依赖？
3. 是否改变了状态不变量？

举个简单的栗子，对字段合法性的验证：  
明显的问题：UI-> 验证。 
潜在的问题：数据修复脚本，历史数据和第三方系统，字段的空验证与格式验证冲突。  
状态不变量：    
1. 这里主要是数据校验相关的行为，会不会影响到系统状态。  
2. 字段是否在某些流程必须有值。  
3. 字段在业务领域：
```
订单状态 = PAID → payment_id 必须存在

用户状态 = ACTIVE → 必须有 verified_at

关键字段只读等等
```

一旦影响到了业务领域QA一般会需要全量回归相关状态迁移。  
全量回归相关状态迁移并不是穷举所有case，这是一个严格限定范围、但要求深度的 QA 行为，说起来很高大上其实就三个主要的因素： 
1. 状态（state）  
2. 迁移（transition）  
3. 规则（invariant）  

```
字段：verified_at
规则：user.status = ACTIVE → verified_at != null
```

相关可转移状态可能包括：
```
PENDING
ACTIVE
SUSPENDED
DELETED
```

通过状态迁移矩阵可以非常直观的了解到某字段全量回归相关状态迁移的整体面貌：  
| 起始状态      | 目标状态     |  是否允许     |  要求     |  回归     |
| ----------- | ----------- | ----------- | ----------- | ----------- |
| PENDING      | ACTIVE    | 是       | 必填       | 是       |
| ACTIVE   | ACTIVE        |否       | 只读       | 是       |
| ACTIVE      | SUSPENDED    | 是       | 无       | 否       |
| DELETED   | ACTIVE        |否      | 无       | 否       |

这里还有一个比较容易忽略的点，就是历史数据迁移，所以还需要验证：  
1. 数据是否能被读取。  
2. 数据是否能被修改。  

如果一个 bug 被修过、又以另一种形式回来，那几乎可以肯定：**修的是表象，不是模型**。  

如果一个团队里： 
QA 被要求“保证质量”  
开发被允许“快速迭代”  
需求不断变化又希望“bug 越来越少”  
那不是 QA 不够敏捷，那是管理层在做不可能三角的自欺。