---
layout: post
title:  "银行系统的架构原理"
date:   2025-12-24 10:48:41 +0800
categories: 架构
---

一位银行运维如果在维护银行数据库的时候把一个的账户金额UPDATE后会被发现吗？

答案其实非常简单：“那几乎不可能！”

为什么呢，因为大家看到的账户balance 其实是一个临时的数据，它的来源是你的账户交易记录。
就是说你改了这个balance 审计那边一眼就能看出问题，你的交易记录跟你的balance完全对不上。更准确的描述余额是“约束下的结果”，不是自由字段。

这个账户交易记录长什么样呢？
年纪稍微大点的人一定见过存折这种东西，上面有你的每次存取记录以及账户余额balance。

这里不得不提到银行的系统的基石：**复式记账**

复式记账是源于会计的语言，其设计的目的就是为了解决：  
1. 控制资产、负债和资本的平衡关系。
2. 防止账目造假和漏记。

会计有条恒等式 **资产 = 负债 + 权益** 
就是说你存钱不仅仅是你自己的账户变化，银行那边的账户也有变化。

举个最简单的例子：

你往银行存 100 元  

银行角度	变化  
资产	  借：+100 现金  
负债	  贷：+100 存款  

稍微补充下会计语言里面的借/贷，这跟借钱还钱什么的没有关系，而是一种约定俗成的**记账方向**。
简单记忆：  
资产/费用：借增贷减  
负债/所有者权益/收入：贷增借减  

简单来说这些约束意味着系统需要随时保证平衡，你系统内的任何变量的变化都会打破这种平衡，而系统需要通过各种约束来保证这种平衡。

如果我们根据以上原则来设计一个系统。
1. 控制资产、负债和资本的平衡关系： 这条原则告诉我们，数据模型不能搞成一张流水表，而是不可能被破坏的约束。

这意味着下面这种流水表，是不能保证系统平衡的：
```
transactions(id, amount, type)
```

而下面的约束是系统平衡为前提的设计：
```
Account(id, type)                       // 资产 / 负债 / 权益
LedgerEntry(account_id, debit, credit)  //账变动(最小不可分)
Journal(id, date)                       //事务边界，一个具体事件 e.g.客户存款/支付工资/收到货款
JournalLine(journal_id, account_id, debit, credit)  //这事件对账户的具体影响
```

2. 防止账目造假和漏记：不平衡的数据根本进不了库。

交易原子性，借贷不能分割：  
```
Journal:
  - 借：现金资产 +100
  - 贷：客户存款负债 +100
```

写入前校验是否借贷平衡：  
```
SUM(debit) == SUM(credit)
```

其他：用户存款总额根据交易记录计算出来，那么数据库的权限设计从实用和安全方面考虑也只允许INSERT根本用不着UPDATE。

最后的结果  
```
balance = SUM(debit) - SUM(credit)   // 对资产类
balance = SUM(credit) - SUM(debit)   // 对负债/权益类
```

可以看到在银行系统里，**数据不是“设计模式”，而更像是因果，存款不是某个字段而是一串条件下的必然结果**。

当然这些也并非数字时代才有的东西，早在计算机发明前人类就已经在手工记账了。现代银行系统不过是前人的智慧与现代技术的共同成果。

最后一个小问题，为什么你看到很多商业系统名义上复试记账实则单边呢？  
这是因为很多商业系统保证的是： 流程正确 > 数字看起来对 > 会计守恒

判断一个系统是否真复式记账也很简单：  
1. 系统层是否“禁止单边写入”。  
2. 能不能“直接改余额”。（文章开头提到的）  
3. 账的“因果”是否可追溯。  

没错商业系统多数是运营型的系统，主要保证业务流程的通畅。报表更多的是为了“解释”，而不是数据层的“约束”。  
而且现代系统很多都是模块型的设计，对大家熟悉的进销存系统来说会计也就是个独立模块，当然这也是为了“性能”和“易用性”所作出的妥协。商业系统需要各种历史兼容，客户嫌慢、嫌复杂。这就些导致了余额都是维护出来而非推导的，最后就有了**逻辑上是复式，因果上是单边**的系统，架构一开始就不是会计中心化的，后面再怎么补都很难变真复式，当然还有很多组织层面的问题这里就不具体展开了。