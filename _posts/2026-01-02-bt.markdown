---
layout: post
title:  "数据库的B+树索引在SSD硬盘中是否还有意义"
date:   2026-01-02 11:07:41 +0800
categories: 算法与数据结构
---

机械硬盘的工作原理是一堆高速旋转的金属盘片 + 磁性涂层，用磁化方向来存 0 和 1。  
它的大致工作流程是：  
1. 访问一个数据块，盘片持续旋转。  
2. 磁头移动到目标磁道（寻道时间）。  
3. 等目标扇区转到磁头下方（旋转延迟）。  
4. 磁头感应磁场变化转化为电信号然后通过一系列转化后传给系统。  

所以数据都是分散的存在磁盘各处，在读取的时候就需要寻道。在数据库表中，存在大量的数据，一旦读取就导致了磁头左右横跳，慢到几乎没法用。聪明的人们为了优化读取/查询时间，就搞出了索引这么个东西，索引的本质其实就是一张类似字典目录的“有序的定位表”，用空间换时间。  

但是因为计算机的特殊结构，实现一些概念和方法需要借助数据结构，而索引用的就是**B+ 树**。  
B+ 树是一类较为高级的数据结构，其操作规则稍微麻烦（当然基本操作还是查询，插入和删除），这里就不具体展开了，想了解的可以参考这里 [B+树](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91)。   

因为在机械硬盘中磁头寻道是个很慢的过程，要解决这个问题，就要尽量的减少磁盘寻道，而选用B+树作为索引的最大原因是因为： 
1. 一个节点存很多key。
2. 其树高度极低（3～4 层就能放千万行）。
3. 顺序遍历极快。  

由于B+树十分矮胖，这里以Mysql InnoDB为例，典型大小为16KB为一页，非叶子节点大概有1000个子节点，一次磁盘IO等于读一个页，可以看到一次查询只需要3到4次随机IO，大大降低了磁盘寻道的次数。  

在访问数据的时候（Mysql InnoDB）：  
1. 从 root 节点开始，一层一层往下（二分定位）。
2. 找到叶子节点。
3. 拿到主键，回表查整行（如果不是覆盖索引）。  

```
1000³ = 1,000,000,000 行 
```   
可以看到就算是10亿级别的数据，也只要4次磁盘页访问。  

B+树，大大降低了IO次数，但是今天的SSD硬盘IO极快，是不是这种数据结构意义不大了？  

只能说B+树不再是唯一方案了，现在有LSM Tree等方案来解决不同场景下的需求，但是B+树仍有自己不可替代的地方，在SSD时代，B+树已经半内存化了，root和中间节点几乎常驻内存，我们之前看到B+树的读规则是顺着叶子链表扫描，所以这种方式定位精确，延迟稳定，内存命中率高，IO抖动小P99稳定性高。  

所以今天的B+树解决的是结构性系统问题，而不是简单的延迟/性能问题。